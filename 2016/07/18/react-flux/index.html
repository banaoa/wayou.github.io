<!DOCTYPE html>
  <head>
  
  <title>给自己的Flux普及读本 | 刘哇勇的部落格</title>
  <meta charset="UTF-8">
  
  
  <link href="/favicon.ico" rel="icon"/>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Wayou Liu">
  
  <link rel="canonical" href="https://wayou.github.io/2016/07/18/react-flux/"/>
  <meta name="description" content="话说当时做 APP 时，三月不知肉味，再次将眼光投放前端，有种天上一天，地下一年的感觉。">
<meta name="keywords" content="reactjs,flux">
<meta property="og:type" content="article">
<meta property="og:title" content="给自己的Flux普及读本">
<meta property="og:url" content="https://wayou.github.io/2016/07/18/react-flux/index.html">
<meta property="og:site_name" content="刘哇勇的部落格">
<meta property="og:description" content="话说当时做 APP 时，三月不知肉味，再次将眼光投放前端，有种天上一天，地下一年的感觉。">
<meta property="og:image" content="https://wayou.github.io/2016/07/18/react-flux/1.png">
<meta property="og:updated_time" content="2017-06-17T13:10:56.042Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="给自己的Flux普及读本">
<meta name="twitter:description" content="话说当时做 APP 时，三月不知肉味，再次将眼光投放前端，有种天上一天，地下一年的感觉。">
<meta name="twitter:image" content="https://wayou.github.io/2016/07/18/react-flux/1.png">
<meta name="twitter:creator" content="@liuwayong">
<link rel="publisher" href="+WayouLiu">
<meta property="fb:admins" content="liuwayong">
<meta property="fb:app_id" content="liuwayong">
  <link href="/img/logo.png" rel="shortcut icon"/>
  <!--<link href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet">-->
  <link rel="stylesheet" href="/lib/waves/waves.css">
  <link rel="stylesheet" href="/lib/tocbot/tocbot.css">
  <link rel="stylesheet" href="/style/style.css">        
  
<!-- Google analyse -->
<script>
  // if(new Date().getTimezoneOffset()/60 == -8) /*disable for china */ return;
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-46794744-6', 'auto');
  ga('send', 'pageview');

</script>

<link rel="stylesheet" href="/css/prism-atom-dark.css" type="text/css"></head>
  <body>
    <header>
  <div class="header-wrap clearfix">
      <div class="header-content">
          <a class="logo-wrap ink" href="/">          
            <img class="logo" src="/logo.png" alt="">
            <span class="site-name">刘哇勇的部落格</span>          
        </a>
        <div class="menu-wrap">
            <div class="header-burger" onclick="document.body.classList.toggle('open')">
                <div></div>
            </div>
        </div>
      </div>
      <nav class="header-nav">
          <ul>
           
              <li class="nav-item ink">
                  <a class="nav-link" href="/">
                      首页
                  </a>
              </li>
           
              <li class="nav-item ink">
                  <a class="nav-link" href="/archives">
                      归档
                  </a>
              </li>
           
              <li class="nav-item ink">
                  <a class="nav-link" href="/about">
                      关于
                  </a>
              </li>
           
              <li class="nav-item ink">
                  <a class="nav-link" href="/atom.xml">
                      订阅
                  </a>
              </li>
              
          </ul>
      </nav>
  </div>
</header>
        
    <div class="container clearfix">
  <div class="col col-sidebar">
    
      <!--placeholder-->
      <p></p>
      <div class="toc js-toc"></div>
    
  </div>
  <div class="col col-main">
    <article>
      <h1>给自己的Flux普及读本</h1>
      <section class="post-info">
    <div class="post-date">
        <i class="material-icons md-dark">watch_later</i>
        1 年前
    </div>
              
        <div class="post-categories">
        <i class="material-icons md-dark">folder</i>
        <a class="category-link" href="/categories/前端/">前端</a>
        </div>
    
    
    <div class="post-tags">
    <i class="material-icons md-dark">local_offer</i>
    <a class="tag-link" href="/tags/flux/">flux</a>, <a class="tag-link" href="/tags/reactjs/">reactjs</a>
    </div>
    
</section>
      <section class="post-content">
        <p>话说当时做 APP 时，三月不知肉味，再次将眼光投放前端，有种天上一天，地下一年的感觉。</p>
<a id="more"></a>
<h2 id="Flux-是一种思想"><a href="/2016/07/18/react-flux/#Flux-是一种思想" class="headerlink" title="Flux 是一种思想"></a>Flux 是一种思想</h2><p>了解的最好方式当然是看<a href="https://facebook.github.io/flux/docs/overview.html" target="_blank" rel="external">Flux官方文档</a>了。React 中文站点也能找到对应的<a href="http://reactjs.cn/react/docs/flux-overview.html" target="_blank" rel="external">翻译版本</a>，但及时性可能无法保证。</p>
<p>老实说，Flux 不算框架，它算是一种编程思想，抑或是一种程序设计范式(Design Pattern)，与前端组件化的编程思想 react 相辅相成。</p>
<blockquote>
<p>It’s more of a pattern rather than a formal framework,</p>
</blockquote>
<p>既然只是一种范式，可以看作是程序编写过程中的一种指导，具体的实现就因人而异了。</p>
<p>现在世面上各种牌子的 Flux 实现都有，选择的空间很大，<a href="https://github.com/kriasoft/react-starter-kit/issues/22" target="_blank" rel="external">Which Flux implementation should I use? </a>这个 issue 里倒是列出了一些并附上了 npm 的下载量。</p>
<p>我们注意到 <a href="https://github.com/reactjs/redux" target="_blank" rel="external">Redux</a> 在其中是比较瞩目的一个，之一。</p>
<p>虽然从最近更新的 <a href="http://redux.js.org/" target="_blank" rel="external">Redux 文档</a>来看，</p>
<blockquote>
<p>Can Redux be considered a Flux implementation?</p>
<p>Yes, and no.</p>
<p>— <a href="http://redux.js.org/docs/introduction/PriorArt.html" target="_blank" rel="external">Redux Doc 1.3-Prior Art</a></p>
</blockquote>
<p>对于它是否是 Flux 的一种实现还有争论，但了解 Flux 对于我们搞清楚时下前沿技术，保持技术人员的先进性，使用 Redux，也是有帮助的。但老实说，Flux 早在2014就出现在公众视野了，到现在已算不得有多新。</p>
<h2 id="Flux-与-React"><a href="/2016/07/18/react-flux/#Flux-与-React" class="headerlink" title="Flux 与 React"></a>Flux 与 React</h2><p>React 将界面组件化，并实现了由数据驱动的层叠式更新。这过程中数据成为了程序中最为关键的一环。在传统的 MVC 模式下，React 可以看作是 View 层面的东西，而其他方面，逻辑及状态管理，则需要 React 之外的东西来接管，Flux 应运而生。</p>
<p><strong>单向数据流</strong>，这些一核心理念可以和 React 很好地补充。当然也有另一层意思，Flux 不一定与 React 搭配才能用。用户在 React 组件上进行交互，视图将操作通过 Action 的形式由 Dispatcher 进行分发，各个Store 注册并接收，处理自己所负责的 Action，然后将更新重新反映到视图上。</p>
<p>整个流程下来，负责程序某一组件的 Store 只需要发送更新，而不用关心视图怎样根据状态来变更。这种做法很符合 React 的声明式编程风格（Declarative programming style）。</p>
<blockquote>
<p><strong>强势插入科普环节</strong></p>
<p>与声明式编程相对应的是命令式编程（Imperative programming），具体来说，</p>
<ul>
<li>声明式编程是告诉计算机你想要的结果，具体过程由计算机自动完成</li>
<li>命令式编程则是事先告诉计算机操作步骤，你期待的输出则可能会在程序执行完后出现</li>
</ul>
<p>了解更多可以参见 StackOverflow 的这个提问<a href="http://stackoverflow.com/questions/33655534/difference-between-declarative-and-imperative-in-react-js" target="_blank" rel="external">Difference between declarative and imperative in React.js?</a></p>
</blockquote>
<p>但是为什么说 React 是声明式的编程风格呢？想想用 React 编程的时候，你通过掌控流程和状态，告诉程序此刻应该是什么样子，而根据当前状态各视图要怎样切换，你无需多管，反正最终组合后的结果，就是你想要的样子。</p>
<h2 id="Flux-的组成"><a href="/2016/07/18/react-flux/#Flux-的组成" class="headerlink" title="Flux 的组成"></a>Flux 的组成</h2><p>是时候祭出这张图了。</p>
<p><img src="/2016/07/18/react-flux/1.png" alt="来自 Flux 官方文档里的示意图"><span class="image-caption">来自 Flux 官方文档里的示意图</span></p>
<p>Flux 的理念里，包含三个重要组成部分。Actions，Dispatcher 和 Stores。如果有第四个的话，我想可能是 Controller Views。</p>
<p>各部分的关系可从上图看出一二。用户的操作触发 Action，由统一的 Dispatcher 来分发，Store 接收到 Action 后各自进行处理，更新自己的数据和所负责的 View。</p>
<h3 id="Actions"><a href="/2016/07/18/react-flux/#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>“我其实就一普通对象”，面对我们的镜头，Action 耸了耸肩。</p>
<p>是的，Action 就是一个普通的 JS 对象，里面包含了这次动作所携带的新数据。约定Action 对象里包含一个唯一标识该动作的字段（一般用常量表示），这样在 Store 接收到该 Action 时可以用来判断是否需要处理该 Action。</p>
<p><a href="https://github.com/facebook/flux/blob/master/examples/flux-todomvc/js/actions/TodoActions.js#L20-L25" target="_blank" rel="external">代码来自官方 TODO 示例里面TodoActions.js</a></p>
<pre class=" language-js"><code class="language-js"><span class="token operator">...</span>
<span class="token comment" spellcheck="true">/**
 * @param  {string} text
 */</span>
create<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  AppDispatcher<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    actionType<span class="token punctuation">:</span> TodoConstants<span class="token punctuation">.</span>TODO_CREATE<span class="token punctuation">,</span>
    text<span class="token punctuation">:</span> text
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token operator">...</span>
</code></pre>
<p>可以说，Actions 连接了视图与 Dispathcer，负责发起一个动作来触发数据更新。这个动作可以是来自界面用户的操作，也可以是异步请求的返回。</p>
<p>Action 只是个普通对象，只有将它发送到 Dispathcer 才会发光发热。像上面代码中，创建一个 ToDo Item 的<code>create</code>方法，便是一个封装我们的 Action，将它发送到 Dispathcer 的方法。我们称之为 Action creator。而 TodoActions.js 则是集合了很多 Action creator 的对象。这个 Action 会在用户点击「添加」按钮时调用。</p>
<p>我们当然可以在点击事件里直接调用 Dispather 来发送 Action，但当程序庞大的时候，这样做不利于维护。View 层面不应该直接与 Dispather 打交道，它只需要完成分内的事情：响应交互，从 Store 获取数据渲染自己。而且，这样包装的另一好处是代码更加语义化，一看便知道是创建操作，将 Actoin 的创建融合在一起，也方便管理。</p>
<h3 id="Dispatcher"><a href="/2016/07/18/react-flux/#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>“你一定学过计算机原理，所以你一定知道集成总线（bus）。” 面对我们的镜头，Dispather 侃侃而谈，没有 Action 的拘谨，“对，我就是那根总线。”</p>
<p>一个 Flux 程序中只有唯一一个 Dispatcher。 Store 会在它上面注册回调，它将 Action 分发给所有注册过回调的 Store。它充当中央调度员的角色，管理所有的 Action 分发。</p>
<p>按照官方的解释，之所以 Actions 需要经过一个统一的 Dispather 进行派发，是因为大型项目下，可以方便地管理 Action 之间的依赖。实际使用中，一些操作依赖于另一个操作的完成。当我们的 Action 都经过一个地方处理后，可以很容易实现这样的依赖，Dispather 则会提供<code>waitFor</code>方法供我们使用。</p>
<h4 id="Dispatch-中的依赖管理示例"><a href="/2016/07/18/react-flux/#Dispatch-中的依赖管理示例" class="headerlink" title="Dispatch 中的依赖管理示例"></a>Dispatch 中的依赖管理示例</h4><p>Store 在向 Dispatcher 注册回调时，会得到一个返回值，这个值是该回调在 Dispatcher 中的索引值，能够唯一标识该回调。</p>
<p>代码来自 Flux 官方文档</p>
<pre class=" language-js"><code class="language-js">PrependedTextStore<span class="token punctuation">.</span>dispatchToken <span class="token operator">=</span> Dispatcher<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>拿到这个索引值，我们便可以在<code>waitFor</code>方法中指定需要等待的操作了。</p>
<p>代码来自 Flux 官方文档</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">case</span> <span class="token string">'TODO_CREATE'</span><span class="token punctuation">:</span>
  Dispatcher<span class="token punctuation">.</span><span class="token function">waitFor</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
    PrependedTextStore<span class="token punctuation">.</span>dispatchToken<span class="token punctuation">,</span>
    YetAnotherStore<span class="token punctuation">.</span>dispatchToken
  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  TodoStore<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>PrependedTextStore<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> action<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
</code></pre>
<p>上面的示例中，会在<code>TODO_CREATE</code>的操作会在<code>PrependedTextStore</code>和<code>YetAnotherStore</code>执行完成后才开始执行。</p>
<h3 id="Stores"><a href="/2016/07/18/react-flux/#Stores" class="headerlink" title="Stores"></a>Stores</h3><p>Store 中包含了程序的状态和逻辑。可以类比 MVC 模式中的 Model。但一如官方文档所解释的那样，MVC 中的 Model 更多的是一个单独ORM对象，是对现实世界个体的抽象，比如 Person，Cat。 而 Store 则是可以看成是多种对象的组合，每个对象又只取需要的部分，它负责的是程序中一个组件中状态的管理，所以它里面的状态数据是和所负责的程序区域相关的，而并不是以 ORM 对象为单位的。</p>
<p>如此说来我倒觉得有点像MVVM中的 View Model。</p>
<p>譬如聊天框，它可能包含联系人列表中的数据，用于在输入<code>@</code>的时候进行提示，也会包含富文本对象用于插入种类媒体信息，与此同时，它本身还有一个输入值的模型。总之，这个<code>InputStore</code>里组装了所需的状态。</p>
<p>Store 向 Dispatcher 注册回调，这个回调接收 Action 作为入参。前面说道，Dispatcher接收到 Action 后会分发给所有注册过回调的 Store，所以在 Store 里，一般会有<code>switch</code>语句去与 Action 中的类型进行比较，以判断是否是这个 Store 关心的 Action，Store 只对自己关心的 Action 作出反应，更新状态。</p>
<p>Store 更新自己后，向外派发 <code>change</code> 事件，controller-views 监听change 事件，从 store 获取到新数据，然后派发给所有 View 上的子节点。</p>
<p>关于 Store, 另一个重要的点是：Store 接收 Action 后自己处理内部的逻辑并更新相应的状态数据，一轮更新下来后所有 Store 各自井然有序，内部的状态没有对外暴露，改变的唯一方法就是通过 Action。</p>
<p>状态只在各自的 store 里管理，程序各组件状态的分离，可以达到高度解耦的目的。由单向数据流来驱动，一目了然。而双向绑定及不够细化的各状态，会导致一处变动，很多地方跟着变动，而这些变化都由开发者自己维护，程序复杂后便不太好掌控全局了。</p>
<h3 id="关于-Controller-Views"><a href="/2016/07/18/react-flux/#关于-Controller-Views" class="headerlink" title="关于 Controller-Views"></a>关于 Controller-Views</h3><p>视图很好理解，如果是用 React，视图便是组件调用形成的树上面的各个绿叶，它们是用户看到的视图。而Controller-Views,
可以结合 React 的<a href="https://facebook.github.io/react/docs/tutorial.html#controlled-components" target="_blank" rel="external">Controlled components</a>来理解。虽然是两样东西，但都可以理解为绑定了数据后被数据所控制，所以叫 ‘controller’,’controlled’。</p>
<p>严格来说，数据驱动的情况下，谁又不是被数据所绑定和控制的呢，这里 controll-views 更强调的是作为根结点，与数据源打交道的这么一个角色，这么一层视图。它监听来自 Store 的<code>change</code>事件，然后向 Store 获取最新的数据，接下来把数据沿着组件树向下派发，通知各个组件更新。这里就完全进入 React 了，组件内部通过调用 <code>setSate()</code>或者<code>forceUpdate()</code>来重新触发<code>render()</code>方法，以达到视图重新渲染的目的。</p>
<h2 id="Flux-学习资料"><a href="/2016/07/18/react-flux/#Flux-学习资料" class="headerlink" title="Flux 学习资料"></a>Flux 学习资料</h2><p>Awesome 系列! Github 上的 <a href="https://github.com/enaqx/awesome-react" target="_blank" rel="external">awesome react</a> 仓库里面，<a href="https://github.com/enaqx/awesome-react#flux" target="_blank" rel="external">flux 部分</a>。</p>
<p>顺便说一句，如果你要找资料，哪都不用去，直接在 github 上找该技术的 awesome 系列准没错。这个系列的特点是，内容多而全，大都还免费，缺点是在纷繁的世界里需要自己去甄别好与坏，awesome 的不一定都 awesome，适合的才是对味的。</p>
<p>Happy coding :)</p>
<h2 id="参考"><a href="/2016/07/18/react-flux/#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://facebook.github.io/flux/docs/overview.html" target="_blank" rel="external">Overview from Flux Official Doc</a></li>
<li><a href="https://scotch.io/tutorials/getting-to-know-flux-the-react-js-architecture" target="_blank" rel="external">Getting To Know Flux, the React.js Architecture</a></li>
</ul>

      </section>
    </article>

    
      <div class="pager">
        
            <a class="post-prev pager-item" href="/2017/06/16/import-data-into-google-sheets-from-web-page/">
              <strong class="article-nav-caption">上一篇</strong>
              <p class="post-nav-title truncate-text">导入网页数据到 Google Sheet</p>
            </a>
        
        
            <a class="post-next pager-item" href="/2016/07/07/css-nth/">
              <strong class="article-nav-caption">下一篇</strong>
              <p class="post-nav-title truncate-text">CSS3 nth 伪类选择器</p>
            </a>
        
      </div>
    

    <!-- comments -->
    <div class="comment-section">
  
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
            this.page.url = 'https://wayou.github.io/2016/07/18/react-flux/'; 
            this.page.identifier = '_posts/2016-07-18-react-flux.md';
        };
        (function() {  
            var d = document, s = d.createElement('script');
            s.src = '//wayou.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
  
</div>


  </div>
</div>
    <footer class="footer">
    <p>由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动，搭载<a title="under developing..." href="javascript:;">末名</a>主题</p>
    <p>
        &copy; 2017 Wayou Liu
    </p>
</footer>
<script src="/lib/waves/waves.js"></script>
<script src="/lib/tocbot/tocbot.js"></script>
<script src="/js/main.js"></script>

  </body>
</html>
